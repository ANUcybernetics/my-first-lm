#!/usr/bin/env -S uv run --script
# /// script
# dependencies = ["typer"]
# ///

"""
Bigram counter that uses the Rust CLI tool to generate bigram data,
then formats it as a tab-separated table for spreadsheet use.
"""

import json
import subprocess
import sys
from collections import defaultdict
from pathlib import Path
from tempfile import NamedTemporaryFile

import typer


def run_rust_tool(input_file: Path, output_file: Path) -> None:
    """
    Run the Rust my_first_lm tool to generate bigram JSON output.

    Args:
        input_file: Path to input text file
        output_file: Path where JSON output will be written
    """
    # Check if the binary exists
    rust_binary = Path("./target/release/my_first_lm")
    if not rust_binary.exists():
        # Try to build it
        print("Building Rust tool...", file=sys.stderr)
        result = subprocess.run(
            ["cargo", "build", "--release"], capture_output=True, text=True
        )
        if result.returncode != 0:
            print(f"Error building Rust tool: {result.stderr}", file=sys.stderr)
            raise typer.Exit(1)

    # Run the Rust tool with n=2 for bigrams and --raw for unscaled counts
    result = subprocess.run(
        [str(rust_binary), str(input_file), "-o", str(output_file), "-n", "2", "--raw"],
        capture_output=True,
        text=True,
    )

    if result.returncode != 0:
        print(f"Error running Rust tool: {result.stderr}", file=sys.stderr)
        raise typer.Exit(1)


def parse_json_to_bigram_matrix(
    json_file: Path,
) -> tuple[list[str], dict[str, dict[str, int]]]:
    """
    Parse the JSON output from the Rust tool into a bigram matrix.

    Args:
        json_file: Path to JSON file generated by Rust tool

    Returns:
        Tuple of (sorted vocabulary, matrix as nested dict)
    """
    with open(json_file, "r") as f:
        data = json.load(f)

    # Build vocabulary and matrix
    vocabulary = set()
    matrix = defaultdict(lambda: defaultdict(int))

    # Each entry in data['data'] is [prefix, scale, [word1, cum_count1], [word2, cum_count2], ...]
    for entry in data["data"]:
        if len(entry) < 3:
            continue

        prefix_word = entry[0]
        vocabulary.add(prefix_word)

        # Process the followers
        prev_count = 0
        for i in range(2, len(entry)):
            follower = entry[i]
            if isinstance(follower, list) and len(follower) == 2:
                next_word, cumulative_count = follower
                vocabulary.add(next_word)
                # Calculate actual count from cumulative
                actual_count = cumulative_count - prev_count
                if actual_count > 0:
                    matrix[prefix_word][next_word] = actual_count
                prev_count = cumulative_count

    # Sort vocabulary
    sorted_vocab = sorted(vocabulary)

    return sorted_vocab, dict(matrix)


def output_tsv_matrix(vocabulary: list[str], matrix: dict[str, dict[str, int]]) -> None:
    """
    Output the bigram matrix as a tab-separated table.

    The format is:
    - First row: empty cell, then all vocabulary words
    - Subsequent rows: word, then cumulative counts along the row
    - Empty cells for zero counts

    Args:
        vocabulary: Sorted list of unique words
        matrix: Nested dictionary of bigram counts
    """
    # Print header row
    header = [""] + vocabulary
    print("\t".join(header))

    # Print each row with cumulative counts
    for first_word in vocabulary:
        row = [first_word]
        cumulative = 0
        for second_word in vocabulary:
            count = matrix.get(first_word, {}).get(second_word, 0)
            if count > 0:
                cumulative += count
                row.append(str(cumulative))
            else:
                row.append("")
        print("\t".join(row))


def main(
    filename: Path = typer.Argument(
        ...,
        help="Path to the text file to process",
        exists=True,
        file_okay=True,
        dir_okay=False,
        readable=True,
    ),
) -> None:
    """
    Generate a bigram frequency matrix using the Rust tool and format as TSV.

    The output is a tab-separated table with:
    - Sorted vocabulary in first row and first column
    - Cell (i,j) contains cumulative count up to and including word j for row i
    - Empty cells (not 0) when count is zero
    """
    try:
        # Create a temporary file for the JSON output
        with NamedTemporaryFile(mode="w", suffix=".json", delete=False) as tmp_file:
            tmp_path = Path(tmp_file.name)

        try:
            # Run the Rust tool
            run_rust_tool(filename, tmp_path)

            # Parse JSON and create matrix
            vocabulary, matrix = parse_json_to_bigram_matrix(tmp_path)

            if not vocabulary:
                print("Error: No vocabulary found in the output", file=sys.stderr)
                raise typer.Exit(1)

            # Output as TSV
            output_tsv_matrix(vocabulary, matrix)

        finally:
            # Clean up temporary file
            if tmp_path.exists():
                tmp_path.unlink()

    except Exception as e:
        print(f"Error processing file: {e}", file=sys.stderr)
        raise typer.Exit(1)


if __name__ == "__main__":
    typer.run(main)

// Get configuration from sys.inputs
#let paper_size = sys.inputs.at("paper_size", default: "a4")
#let font_size = sys.inputs.at("font_size", default: "8pt")
#let num_columns = sys.inputs.at("columns", default: "4")
#let subtitle = sys.inputs.at("subtitle", default: "")

#set text(font: "Libertinus Serif", size: eval(font_size))

// how many sided die will the book be optimised for?
#let dice_d = 120

// Load the JSON data
#let json_data = json("model.json")
#let data = json_data.data
#let metadata = json_data.metadata

// Create a state variable to track the current prefix
#let current_prefix = state("current-prefix", "")

// States to track first and last entries on each page for guide words
#let page_entries = state("page-entries", ())

// Function to get model type string from n value
#let model-type(n) = {
  if n == 1 {
    "unigram"
  } else if n == 2 {
    "bigram"
  } else if n == 3 {
    "trigram"
  } else {
    str(n) + "-gram"
  }
}

// Title page function
#let title-page() = {
  set page(margin: (x: 2.5cm, y: 2.5cm))
  align(center + horizon)[
    #v(2cm)
    #text(weight: "bold", size: 4em)[#context metadata.title]
    #v(1cm)
    #text(size: 2.5em)[A #context model-type(metadata.n) language model]
    // Use book_info from metadata if available, otherwise fall back to subtitle parameter
    #context if metadata.at("book_info", default: none) != none {
      v(0.5cm)
      let book_info = metadata.book_info
      text(size: 2em)[#book_info.letter_range (Book #book_info.number of #book_info.total)]
    } else if subtitle != "" {
      v(0.5cm)
      text(size: 2em)[#subtitle]
    }
  ]
  pagebreak()
}

// Copyright page
#let copyright-page() = {
  set page(margin: (x: 2.5cm, y: 2.5cm))
  set text(size: 12pt)
  align(horizon)[
    #text(size: 1.2em)[A #context model-type(metadata.n) language model of]
    #text(size: 1.2em, style: "italic")[#context metadata.title by]
    #text(size: 1.2em)[#context metadata.author]
    #v(0.5cm)

    #text(size: 1em)[© 2025 Cybernetic Studio]
    #v(0.5cm)

    #text(size: 0.9em)[
      This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License (CC BY-NC 4.0).
    ]
    #v(0.5cm)

    // #text(size: 0.9em)[ISBN: 978-0-00000-000-0]
    // #v(0.5cm)
    #text(size: 0.9em)[Published by Cybernetic Studio Press]
    #v(0.5cm)
    #text(size: 0.9em)[First Edition]
    #v(0.5cm)
    #text(size: 0.9em)[
      Text frequency counts from the text #text(style: "italic")[#context metadata.title] by
      #text[#context metadata.author], available from\ #link(metadata.url)[#raw(metadata.url)].
    ]
    #v(0.5cm)
    #text(size: 0.9em)[
      Credits: designed and built by Ben Swift for the Cybernetic Studio.
      Typeset in #link("https://github.com/alerque/libertinus")[Libertinus] using #link("https://typst.app")[Typst].
      The source code for the tool used to create this model is available under an MIT Licence from
      #link("https://github.com/ANUcybernetics/my-first-lm")[`https://github.com/ANUcybernetics/my-first-lm`]
    ]
    #v(0.5cm)
    #text(size: 0.9em, style: "italic")[
      Disclaimer: this reference contains a statistical language model derived from text corpus analysis.
      The patterns within represent probabilistic relationships between words in that text.
      Any new texts generated by sampling from this language model are
      statistical in nature and may not always reflect proper grammar, factual accuracy,
      or appropriate content.
    ]
  ]
  pagebreak()
}

// Introduction page
#let introduction() = {
  set page(margin: (x: 2.5cm, y: 2.5cm))
  align(left)[
    #heading(level: 1)[Introduction]
    #v(0.5cm)
    This reference contains a statistical #context model-type(metadata.n) language model that shows the probabilistic
    relationships between word sequences. Each entry displays a prefix followed by possible
    continuations with their associated probabilities.

    The model can be used for text prediction, generation, and analysis of linguistic patterns.

    #v(0.5cm)
    #heading(level: 2)[How to Read This Reference]
    Each entry contains:
    - A bold prefix sequence
    - A diamond symbol (♢) followed by a number indicating the total occurrence count (only when not equal to 120)
    - Possible continuations with their occurrence counts
  ]
  pagebreak()
}

// Table of contents
#let table-of-contents() = {
  set page(margin: (x: 2.5cm, y: 2.5cm))
  heading(level: 1)[Contents]
  v(1cm)
  // A simple table of contents would be difficult to generate for all prefixes
  // For a real book, you might want to generate sections based on first letters or similar
  [The following pages contain all #context model-type(metadata.n) sequences organized alphabetically by prefix.]
  pagebreak()
}

// Generate front matter
#title-page()
#copyright-page()
// #introduction()
// #table-of-contents()

// Main content with original layout
#set page(
  paper_size,
  margin: (x: 1.5cm, y: 1.5cm),
  columns: int(num_columns),
  numbering: "1/1",
  header: context {
    // Get the entries for this page
    let entries = page_entries.final()
    let current-page = here().page()

    // Skip guide words on first few pages (frontmatter)
    if current-page <= 2 {
      return
    }

    // Find entries on this page
    let page-words = ()
    for entry in entries {
      if entry.page == current-page {
        page-words.push(entry.prefix)
      }
    }

    if page-words.len() > 0 {
      let first = page-words.first()
      let last = page-words.last()
      align(center)[
        #smallcaps(first) — #smallcaps(last)
      ]
    }
  },
  header-ascent: 30%
)

#for (i, item) in data.enumerate() {
  // The first element is the prefix
  let prefix = item.at(0)
  let total_count = item.at(1)
  let followers = item.slice(2)
  current_prefix.update(prefix)

  // Record this entry's location for guide words
  context {
    let loc = here()
    page_entries.update(entries => {
      entries.push((prefix: prefix, page: loc.page()))
      entries
    })
  }

  // this is the prefix text with a label
  // Split prefix into words and display each with appropriate styling
  [#for (i, part) in prefix.split(" ").enumerate() {
    if part == "." or part == "," {
      // Display punctuation in a rounded box with vertical centering
      box(
        rect(
          fill: none,
          stroke: 0.25pt + black,
          radius: 1pt,
          inset: (x: 1pt, y: 0pt),
          outset: (y: 0pt),
          [#text(part, size: 1.5em, weight: "bold", baseline: -0.3em)]
        )
      )
    } else {
      // Display regular words normally
      text(part, size: 1.5em, weight: "bold")
    }
    // Add space between parts except for the last one
    if i < prefix.split(" ").len() - 1 {
      h(0.3em)
    }
  }#label("prefix-" + prefix)]

  // the dice roll number
  if total_count != dice_d {
    h(0.3em)
    [(#box[#text(weight: "bold")[#str(total_count).len()]♢])]
  }

  h(0.6em)

  // the followers for this prefix (with weights)
  for follower in followers {
    let word = follower.at(0)
    // Check if this is a punctuation token
    if word == "." or word == "," {
      // Display punctuation in a rounded box with special styling
      if followers.len() > 1 {
        box([#text(weight: "semibold")[#follower.at(1)]|#box(
          rect(
            fill: none,
            stroke: 0.25pt + black,
            radius: 1pt,
            inset: (x: 1pt, y: 0pt),
            outset: (y: 0pt),
            [#text(weight: "bold", baseline: -0.25em)[#word]]
          )
        )])
      } else {
        box(
          rect(
            fill: none,
            stroke: 0.25pt + black,
            radius: 1pt,
            inset: (x: 1pt, y: 0pt),
            outset: (y: 0pt),
            [#text(weight: "bold", baseline: -0.25em)[#word]]
          )
        )
      }
    } else {
      // Display regular words normally
      if followers.len() > 1 {
        box([#text(weight: "semibold")[#follower.at(1)]|#text[#follower.at(0)]])
      } else {
        box([#follower.at(0)])
      }
    }
    h(0.5em)
  }

  v(0.1em)
}

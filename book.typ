// Get configuration from sys.inputs
#let paper_size = sys.inputs.at("paper_size", default: "a4")
#let font_size = sys.inputs.at("font_size", default: "8pt")
#let num_columns = sys.inputs.at("columns", default: "4")
#let subtitle = sys.inputs.at("subtitle", default: "")

#set text(font: "Libertinus Serif", size: eval(font_size))

// how many sided die will the book be optimised for?
#let dice_d = 120

// Load the JSON data
#let json_data = json("model.json")
#let data = json_data.data
#let doc_metadata = json_data.metadata

// Create a state variable to track the current prefix
#let current_prefix = state("current-prefix", "")

// We'll use doc_metadata to track entries instead of state
// since state.final() might not work properly in headers

// Function to get model type string from n value
#let model-type(n) = {
  if n == 1 {
    "unigram"
  } else if n == 2 {
    "bigram"
  } else if n == 3 {
    "trigram"
  } else {
    str(n) + "-gram"
  }
}

// Function to display text with punctuation in boxes
#let display-with-punctuation(text-content, size: 1.5em, weight: "bold") = {
  let parts = text-content.split(" ")
  for (i, part) in parts.enumerate() {
    if part == "." or part == "," {
      // Display punctuation in a rounded box
      box(
        rect(
          fill: none,
          stroke: 0.25pt + black,
          radius: 1pt,
          inset: (x: 0.1em, y: 0pt),
          outset: (y: 0pt),
          [#text(part, size: size, weight: weight, baseline: -0.2em)],
        ),
      )
    } else if part == "—" {
      // Em dash separator
      text(" — ", size: size, weight: weight)
    } else {
      // Regular words
      text(part, size: size, weight: weight)
    }
    // Add space between parts
    if i < parts.len() - 1 and parts.at(i + 1) != "—" and part != "—" {
      h(0.3em)
    }
  }
}

// Title page function
#let title-page() = {
  set page(margin: (x: 2.5cm, y: 2.5cm))
  align(center + horizon)[
    #v(2cm)
    #text(weight: "bold", size: 4em)[#context doc_metadata.title]
    #v(1cm)
    #text(size: 2.5em)[A #context model-type(doc_metadata.n) language model]
    // Use book_info from doc_metadata if available, otherwise fall back to subtitle parameter
    #context if doc_metadata.at("book_info", default: none) != none {
      v(0.5cm)
      let book_info = doc_metadata.book_info
      text(size: 2em)[#book_info.letter_range (Book #book_info.number of
        #book_info.total)]
    } else if subtitle != "" {
      v(0.5cm)
      text(size: 2em)[#subtitle]
    }
  ]
  pagebreak()
}

// Copyright page
#let copyright-page() = {
  set page(margin: (x: 2.5cm, y: 2.5cm))
  set text(size: 12pt)
  align(horizon)[
    #text(size: 1.2em)[A #context model-type(doc_metadata.n) language model of]
    #text(size: 1.2em, style: "italic")[#context doc_metadata.title by]
    #text(size: 1.2em)[#context doc_metadata.author]
    #v(0.5cm)

    #text(size: 1em)[© 2025 Cybernetic Studio]
    #v(0.5cm)

    #text(size: 0.9em)[
      This work is licensed under a Creative Commons Attribution-NonCommercial
      4.0 International License (CC BY-NC 4.0).
    ]
    #v(0.5cm)

    // #text(size: 0.9em)[ISBN: 978-0-00000-000-0]
    // #v(0.5cm)
    #text(size: 0.9em)[Published by Cybernetic Studio Press]
    #v(0.5cm)
    #text(size: 0.9em)[First Edition]
    #v(0.5cm)
    #text(size: 0.9em)[
      Text frequency counts from the text #text(
        style: "italic",
      )[#context doc_metadata.title] by #text[#context doc_metadata.author],
      available from\ #link(doc_metadata.url)[#raw(doc_metadata.url)].
    ]
    #v(0.5cm)
    #text(size: 0.9em)[
      Credits: designed and built by Ben Swift for the Cybernetic Studio.
      Typeset in #link("https://github.com/alerque/libertinus")[Libertinus]
      using #link("https://typst.app")[Typst]. The source code for the tool used
      to create this model is available under an MIT Licence from
      #link(
        "https://github.com/ANUcybernetics/my-first-lm",
      )[`https://github.com/ANUcybernetics/my-first-lm`]
    ]
    #v(0.5cm)
    #text(size: 0.9em, style: "italic")[
      Disclaimer: this reference contains a statistical language model derived
      from text corpus analysis. The patterns within represent probabilistic
      relationships between words in that text. Any new texts generated by
      sampling from this language model are statistical in nature and may not
      always reflect proper grammar, factual accuracy, or appropriate content.
    ]
  ]
  pagebreak()
}

// Introduction page
#let introduction() = {
  set page(margin: (x: 2.5cm, y: 2.5cm))
  align(left)[
    #heading(level: 1)[Introduction]
    #v(0.5cm)
    This reference contains a statistical #context model-type(doc_metadata.n)
    language model that shows the probabilistic relationships between word
    sequences. Each entry displays a prefix followed by possible continuations
    with their associated probabilities.

    The model can be used for text prediction, generation, and analysis of
    linguistic patterns.

    #v(0.5cm)
    #heading(level: 2)[How to Read This Reference]
    Each entry contains:
    - A bold prefix sequence
    - A diamond symbol (♢) followed by a number indicating the total occurrence
      count (only when not equal to 120)
    - Possible continuations with their occurrence counts
  ]
  pagebreak()
}

// Table of contents
#let table-of-contents() = {
  set page(margin: (x: 2.5cm, y: 2.5cm))
  heading(level: 1)[Contents]
  v(1cm)
  // A simple table of contents would be difficult to generate for all prefixes
  // For a real book, you might want to generate sections based on first letters or similar
  [The following pages contain all #context model-type(doc_metadata.n) sequences
    organized alphabetically by prefix.]
  pagebreak()
}

// Generate front matter
#title-page()
#copyright-page()
// #introduction()
// #table-of-contents()

// Main content with original layout
#set page(
  paper_size,
  margin: (x: 1.5cm, top: 3cm, bottom: 2cm), // Different top and bottom margins
  columns: int(num_columns),
  numbering: "1/1",
  header: context {
    let current-page = here().page()

    // Skip guide words on first few pages (frontmatter)
    if current-page <= 2 {
      return
    }

    // Get all prefix entries and determine guide words for this page
    let all-entries = query(metadata)
    let page-entries = all-entries.filter(m => (
      m.location().page() == current-page
    ))

    let guide-text = if page-entries.len() > 0 {
      // New prefixes on this page
      let prefixes = page-entries.map(e => e.value)
      let first = prefixes.first()
      let last = prefixes.last()
      if first == last { first } else { first + " — " + last }
    } else {
      // No new prefixes - use last prefix before this page
      let entries-before = all-entries.filter(m => (
        m.location().page() < current-page
      ))
      if entries-before.len() > 0 {
        entries-before.last().value
      } else {
        ""
      }
    }

    // Display guide words and horizontal rule
    if guide-text != "" {
      // Position based on odd/even page
      let is-odd = calc.odd(current-page)

      // Create the guide word display (styled like prefix text)
      let guide-display = display-with-punctuation(
        guide-text,
        size: 1.5em,
        weight: "bold",
      )

      // Position guide words on outer edge
      if is-odd {
        align(right)[#guide-display]
      } else {
        align(left)[#guide-display]
      }

      // Add horizontal rule
      line(length: 100%, stroke: 0.5pt)
      // Add 1.5em space after the header to push main content down further
      v(1em)
    }
  },
  header-ascent: 10%, // Further reduced to bring header content down more
)

#for (i, item) in data.enumerate() {
  // The first element is the prefix
  let prefix = item.at(0)
  let total_count = item.at(1)
  let followers = item.slice(2)
  current_prefix.update(prefix)

  // this is the prefix text with a label
  [#metadata(prefix) <prefix-entry>#display-with-punctuation(
      prefix,
      size: 1.5em,
      weight: "bold",
    )#label("prefix-" + prefix)]

  // the dice roll number (showing digit count as a compression indicator)
  if total_count != dice_d {
    h(0.3em)
    box[#text(weight: "bold")[#str(total_count).len()]♢]
  }

  h(0.6em)

  // the followers for this prefix (with weights)
  for follower in followers {
    let word = follower.at(0)
    // Create the display for this follower
    if word == "." or word == "," {
      // Punctuation in a rounded box with count
      if followers.len() > 1 {
        box([#text(weight: "semibold")[#follower.at(1)]|#box(
            rect(
              fill: none,
              stroke: 0.25pt + black,
              radius: 1pt,
              inset: (x: 0.1em, y: 0pt),
              outset: (y: 0pt),
              [#text(weight: "bold", baseline: -0.2em)[#word]],
            ),
          )])
      } else {
        box(
          rect(
            fill: none,
            stroke: 0.25pt + black,
            radius: 1pt,
            inset: (x: 0.1em, y: 0pt),
            outset: (y: 0pt),
            [#text(weight: "bold", baseline: -0.2em)[#word]],
          ),
        )
      }
    } else {
      // Regular word with count
      if followers.len() > 1 {
        box([#text(weight: "semibold")[#follower.at(1)]|#text[#word]])
      } else {
        box([#word])
      }
    }
    h(0.5em)
  }

  v(0.1em)
}

// Get configuration from sys.inputs
#let paper_size = sys.inputs.at("paper_size", default: "a4")
#let font_size = sys.inputs.at("font_size", default: "8pt")
#let num_columns = sys.inputs.at("columns", default: "4")
#let subtitle = sys.inputs.at("subtitle", default: "")

#set text(font: "Libertinus Serif", size: eval(font_size))

// how many sided die will the book be optimised for?
#let dice_d = 120

// Load the JSON data
#let json_data = json("model.json")
#let data = json_data.data
#let doc_metadata = json_data.metadata

// Create a state variable to track the current prefix
#let current_prefix = state("current-prefix", "")

// We'll use doc_metadata to track entries instead of state
// since state.final() might not work properly in headers

// Function to get model type string from n value
#let model-type(n) = {
  if n == 1 {
    "unigram"
  } else if n == 2 {
    "bigram"
  } else if n == 3 {
    "trigram"
  } else {
    str(n) + "-gram"
  }
}

// Title page function
#let title-page() = {
  set page(margin: (x: 2.5cm, y: 2.5cm))
  align(center + horizon)[
    #v(2cm)
    #text(weight: "bold", size: 4em)[#context doc_metadata.title]
    #v(1cm)
    #text(size: 2.5em)[A #context model-type(doc_metadata.n) language model]
    // Use book_info from doc_metadata if available, otherwise fall back to subtitle parameter
    #context if doc_metadata.at("book_info", default: none) != none {
      v(0.5cm)
      let book_info = doc_metadata.book_info
      text(size: 2em)[#book_info.letter_range (Book #book_info.number of #book_info.total)]
    } else if subtitle != "" {
      v(0.5cm)
      text(size: 2em)[#subtitle]
    }
  ]
  pagebreak()
}

// Copyright page
#let copyright-page() = {
  set page(margin: (x: 2.5cm, y: 2.5cm))
  set text(size: 12pt)
  align(horizon)[
    #text(size: 1.2em)[A #context model-type(doc_metadata.n) language model of]
    #text(size: 1.2em, style: "italic")[#context doc_metadata.title by]
    #text(size: 1.2em)[#context doc_metadata.author]
    #v(0.5cm)

    #text(size: 1em)[© 2025 Cybernetic Studio]
    #v(0.5cm)

    #text(size: 0.9em)[
      This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License (CC BY-NC 4.0).
    ]
    #v(0.5cm)

    // #text(size: 0.9em)[ISBN: 978-0-00000-000-0]
    // #v(0.5cm)
    #text(size: 0.9em)[Published by Cybernetic Studio Press]
    #v(0.5cm)
    #text(size: 0.9em)[First Edition]
    #v(0.5cm)
    #text(size: 0.9em)[
      Text frequency counts from the text #text(style: "italic")[#context doc_metadata.title] by
      #text[#context doc_metadata.author], available from\ #link(doc_metadata.url)[#raw(doc_metadata.url)].
    ]
    #v(0.5cm)
    #text(size: 0.9em)[
      Credits: designed and built by Ben Swift for the Cybernetic Studio.
      Typeset in #link("https://github.com/alerque/libertinus")[Libertinus] using #link("https://typst.app")[Typst].
      The source code for the tool used to create this model is available under an MIT Licence from
      #link("https://github.com/ANUcybernetics/my-first-lm")[`https://github.com/ANUcybernetics/my-first-lm`]
    ]
    #v(0.5cm)
    #text(size: 0.9em, style: "italic")[
      Disclaimer: this reference contains a statistical language model derived from text corpus analysis.
      The patterns within represent probabilistic relationships between words in that text.
      Any new texts generated by sampling from this language model are
      statistical in nature and may not always reflect proper grammar, factual accuracy,
      or appropriate content.
    ]
  ]
  pagebreak()
}

// Introduction page
#let introduction() = {
  set page(margin: (x: 2.5cm, y: 2.5cm))
  align(left)[
    #heading(level: 1)[Introduction]
    #v(0.5cm)
    This reference contains a statistical #context model-type(doc_metadata.n) language model that shows the probabilistic
    relationships between word sequences. Each entry displays a prefix followed by possible
    continuations with their associated probabilities.

    The model can be used for text prediction, generation, and analysis of linguistic patterns.

    #v(0.5cm)
    #heading(level: 2)[How to Read This Reference]
    Each entry contains:
    - A bold prefix sequence
    - A diamond symbol (♢) followed by a number indicating the total occurrence count (only when not equal to 120)
    - Possible continuations with their occurrence counts
  ]
  pagebreak()
}

// Table of contents
#let table-of-contents() = {
  set page(margin: (x: 2.5cm, y: 2.5cm))
  heading(level: 1)[Contents]
  v(1cm)
  // A simple table of contents would be difficult to generate for all prefixes
  // For a real book, you might want to generate sections based on first letters or similar
  [The following pages contain all #context model-type(doc_metadata.n) sequences organized alphabetically by prefix.]
  pagebreak()
}

// Generate front matter
#title-page()
#copyright-page()
// #introduction()
// #table-of-contents()

// Main content with original layout
#set page(
  paper_size,
  margin: (x: 1.5cm, y: 1.5cm),
  columns: int(num_columns),
  numbering: "1/1",
  header: context {
    let current-page = here().page()

    // Skip guide words on first few pages (frontmatter)
    if current-page <= 2 {
      return
    }

    // Query ALL metadata entries up to this point
    let all-entries = query(<prefix-entry>)

    // Find entries on this page
    let page-entries = all-entries.filter(m => m.location().page() == current-page)

    if page-entries.len() > 0 {
      // There are new prefixes on this page
      let prefixes = page-entries.map(e => e.value)
      let first = prefixes.first()
      let last = prefixes.last()

      if first == last {
        align(center)[
          #smallcaps(first)
        ]
      } else {
        align(center)[
          #smallcaps(first) — #smallcaps(last)
        ]
      }
    } else {
      // No new prefixes on this page - use the last prefix before this page
      let entries-before = all-entries.filter(m => m.location().page() < current-page)
      if entries-before.len() > 0 {
        let last-prefix = entries-before.last().value
        align(center)[
          #smallcaps(last-prefix)
        ]
      }
    }
  },
  header-ascent: 30%
)

#for (i, item) in data.enumerate() {
  // The first element is the prefix
  let prefix = item.at(0)
  let total_count = item.at(1)
  let followers = item.slice(2)
  current_prefix.update(prefix)

  // this is the prefix text with a label
  // Split prefix into words and display each with appropriate styling
  [#metadata(prefix) <prefix-entry>#for (i, part) in prefix.split(" ").enumerate() {
    if part == "." or part == "," {
      // Display punctuation in a rounded box with vertical centering
      box(
        rect(
          fill: none,
          stroke: 0.25pt + black,
          radius: 1pt,
          inset: (x: 1pt, y: 0pt),
          outset: (y: 0pt),
          [#text(part, size: 1.5em, weight: "bold", baseline: -0.3em)]
        )
      )
    } else {
      // Display regular words normally
      text(part, size: 1.5em, weight: "bold")
    }
    // Add space between parts except for the last one
    if i < prefix.split(" ").len() - 1 {
      h(0.3em)
    }
  }#label("prefix-" + prefix)]

  // the dice roll number
  if total_count != dice_d {
    h(0.3em)
    [(#box[#text(weight: "bold")[#str(total_count).len()]♢])]
  }

  h(0.6em)

  // the followers for this prefix (with weights)
  for follower in followers {
    let word = follower.at(0)
    // Check if this is a punctuation token
    if word == "." or word == "," {
      // Display punctuation in a rounded box with special styling
      if followers.len() > 1 {
        box([#text(weight: "semibold")[#follower.at(1)]|#box(
          rect(
            fill: none,
            stroke: 0.25pt + black,
            radius: 1pt,
            inset: (x: 1pt, y: 0pt),
            outset: (y: 0pt),
            [#text(weight: "bold", baseline: -0.25em)[#word]]
          )
        )])
      } else {
        box(
          rect(
            fill: none,
            stroke: 0.25pt + black,
            radius: 1pt,
            inset: (x: 1pt, y: 0pt),
            outset: (y: 0pt),
            [#text(weight: "bold", baseline: -0.25em)[#word]]
          )
        )
      }
    } else {
      // Display regular words normally
      if followers.len() > 1 {
        box([#text(weight: "semibold")[#follower.at(1)]|#text[#follower.at(0)]])
      } else {
        box([#follower.at(0)])
      }
    }
    h(0.5em)
  }

  v(0.1em)
}
